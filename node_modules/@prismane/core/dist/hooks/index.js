import { useState as g, useEffect as p, useRef as C, useCallback as O } from "react";
const k = (e = !1, t = 150, r = "ease") => {
  const [s, c] = g(e);
  return { animating: s, animate: () => {
    c(!s);
  }, duration: t, timing: r };
}, S = (e = 0, t = Number.MIN_SAFE_INTEGER, r = Number.MAX_SAFE_INTEGER) => {
  const [s, c] = g(e);
  return {
    counter: s,
    increment: (l = 1) => {
      c((f) => Math.min(f + l, r));
    },
    decrement: (l = 1) => {
      c((f) => Math.max(f - l, t));
    },
    set: (l) => {
      c(l);
    }
  };
}, T = (e, t = 500) => {
  const [r, s] = g(e);
  return p(() => {
    const c = setTimeout(() => {
      s(e);
    }, t);
    return () => {
      clearTimeout(c);
    };
  }, [e, t]), r;
}, D = (e) => {
  const [t, r] = g(null);
  return p(() => {
    const s = () => {
      setTimeout(() => {
        const c = e.current.getBoundingClientRect(), { top: u, right: i, bottom: a, left: l, width: f, height: v } = c, w = c.left, y = c.top, E = {
          x: l + f / 2,
          y: u + v / 2
        }, b = {
          top: parseInt(window.getComputedStyle(e.current).marginTop, 10),
          right: parseInt(window.getComputedStyle(e.current).marginRight, 10),
          bottom: parseInt(
            window.getComputedStyle(e.current).marginBottom,
            10
          ),
          left: parseInt(window.getComputedStyle(e.current).marginLeft, 10)
        }, h = {
          top: parseInt(window.getComputedStyle(e.current).paddingTop, 10),
          right: parseInt(
            window.getComputedStyle(e.current).paddingRight,
            10
          ),
          bottom: parseInt(
            window.getComputedStyle(e.current).paddingBottom,
            10
          ),
          left: parseInt(window.getComputedStyle(e.current).paddingLeft, 10)
        }, n = {
          top: parseInt(
            window.getComputedStyle(e.current).borderTopWidth,
            10
          ),
          right: parseInt(
            window.getComputedStyle(e.current).borderRightWidth,
            10
          ),
          bottom: parseInt(
            window.getComputedStyle(e.current).borderBottomWidth,
            10
          ),
          left: parseInt(
            window.getComputedStyle(e.current).borderLeftWidth,
            10
          )
        }, o = {
          top: u,
          right: i,
          bottom: a,
          left: l,
          width: f,
          height: v,
          x: w,
          y,
          center: E,
          margin: b,
          padding: h,
          border: n
        };
        o.width -= h.left + h.right + n.left + n.right, o.height -= h.top + h.bottom + n.top + n.bottom, o.x += h.left + n.left, o.y += h.top + n.top, r(o);
      }, 0);
    };
    if (e.current)
      return s(), window.addEventListener("resize", s), () => {
        window.removeEventListener("resize", s);
      };
  }, [e]), t;
}, x = (e = { x: 0, y: 0 }) => {
  const t = C(null), [r, s] = g(!1), [c, u] = g(e);
  return p(() => {
    const i = t.current, a = (v) => {
      s(!0);
      const { pageX: w, pageY: y } = v, { offsetLeft: E, offsetTop: b } = i.offsetParent, { offsetWidth: h, offsetHeight: n } = i;
      u((o) => ({
        x: w - E - h / 2,
        y: y - b - n / 2
      }));
    }, l = (v) => {
      if (r) {
        const { pageX: w, pageY: y } = v, { offsetLeft: E, offsetTop: b } = i.offsetParent, { offsetWidth: h, offsetHeight: n } = i;
        u((o) => ({
          x: w - E - h / 2,
          y: y - b - n / 2
        }));
      }
    }, f = () => {
      s(!1);
    };
    return i && (i.addEventListener("mousedown", a), document.addEventListener("mousemove", l), document.addEventListener("mouseup", f)), () => {
      i && i.removeEventListener("mousedown", a), document.removeEventListener("mousemove", l), document.removeEventListener("mouseup", f);
    };
  }, [r]), { ref: t, isDragging: r, position: c };
}, M = (e, t) => (s) => {
  if (e.current) {
    const c = new Event("input", { bubbles: !0 });
    Object.defineProperty(c, "target", {
      value: e.current,
      writable: !1
    }), e.current.value = s, t(c);
  }
}, V = (e = {}) => {
  const [t, r] = g(() => {
    const n = {
      fields: {},
      validateOn: e.validateOn ? e.validateOn : "all",
      resetOptions: e.resetOptions ? {
        keepDirty: e.resetOptions.keepDirty || !1,
        keepTouched: e.resetOptions.keepTouched || !1,
        keepErrors: e.resetOptions.keepErrors || !1
      } : {
        keepDirty: !1,
        keepTouched: !1,
        keepErrors: !1
      }
    };
    for (const o in e.fields)
      e.fields.hasOwnProperty(o) && (n.fields[o] = {
        value: e.fields[o].value,
        error: e.fields[o].error || null,
        validators: e.fields[o].validators || {},
        isDirty: !1,
        isTouched: !1
      });
    return n;
  }), s = (n) => ({
    onChange: (d) => y(
      n,
      d.target.type === "checkbox" ? d.target.checked : d.target.value
    ),
    onBlur: () => w(n),
    error: f(n),
    value: a(n),
    name: n
  }), c = (n, o) => {
    r((d) => ({
      ...d,
      fields: {
        ...d.fields,
        [n]: {
          ...d.fields[n],
          error: o
        }
      }
    }));
  }, u = (n, o) => {
    r((d) => ({
      ...d,
      fields: {
        ...d.fields,
        [n]: {
          ...d.fields[n],
          value: o,
          isDirty: !0
        }
      }
    }));
  }, i = () => {
    const n = {};
    return Object.keys(t.fields).forEach((o) => {
      n[o] = t.fields[o].value;
    }), n;
  }, a = (n) => {
    var o;
    return (o = t.fields[n]) == null ? void 0 : o.value;
  }, l = () => {
    const n = {};
    return Object.keys(t.fields).forEach((o) => {
      n[o] = t.fields[o].error;
    }), n;
  }, f = (n) => {
    var o;
    return (o = t.fields[n]) == null ? void 0 : o.error;
  }, v = async (n, o) => {
    let d = null;
    const L = t.fields[n].validators;
    for (const m of Object.keys(L))
      if (d = await L[m](o), d)
        break;
    return r((m) => ({
      ...m,
      fields: {
        ...m.fields,
        [n]: {
          ...m.fields[n],
          error: d
        }
      }
    })), d;
  }, w = (n) => {
    r((o) => ({
      ...o,
      fields: {
        ...o.fields,
        [n]: {
          ...o.fields[n],
          isTouched: !0
        }
      }
    })), (t.validateOn === "blur" || t.validateOn === "all") && v(n, t.fields[n].value);
  }, y = (n, o) => {
    r((d) => ({
      ...d,
      fields: {
        ...d.fields,
        [n]: {
          ...d.fields[n],
          value: o,
          isDirty: !0
        }
      }
    })), (t.validateOn === "change" || t.validateOn === "all") && v(n, o);
  }, E = async () => {
    let n = !1;
    for (const o in t.fields) {
      const d = t.fields[o];
      d.validators && await v(o, d.value) && (n = !0);
    }
    return n;
  };
  return {
    formState: t,
    register: s,
    setValue: u,
    setError: c,
    getFormValues: i,
    getValue: a,
    getFormErrors: l,
    getError: f,
    validate: v,
    handleChange: y,
    handleBlur: w,
    validateForm: E,
    handleReset: () => {
      r((n) => {
        var d, L;
        const o = {
          fields: {},
          validateOn: n.validateOn,
          resetOptions: { ...n.resetOptions }
        };
        for (const m in n.fields)
          n.fields.hasOwnProperty(m) && (o.fields[m] = {
            ...n.fields[m],
            value: (L = (d = e.fields) == null ? void 0 : d[m]) == null ? void 0 : L.value,
            error: t.resetOptions.keepErrors ? n.fields[m].error : null,
            isDirty: t.resetOptions.keepDirty ? n.fields[m].isDirty : null,
            isTouched: t.resetOptions.keepTouched ? n.fields[m].isTouched : null
          });
        return o;
      });
    },
    handleSubmit: async (n, o, d) => {
      n.preventDefault();
      const L = await E(), m = i();
      L ? d && d(m) : o(m);
    }
  };
}, N = () => {
  const [e, t] = g("");
  return p(() => {
    t(Math.random().toString(16).slice(2));
  }, []), e;
}, P = (e = 3e3, t = ["mousemove", "keyup", "click", "scroll"], r = !1) => {
  const [s, c] = g(r);
  let u;
  return p(() => {
    const i = () => {
      c(!1), clearTimeout(u), u = setTimeout(() => {
        c(!0);
      }, e);
    };
    return t.forEach((a) => {
      window.addEventListener(a, i);
    }), () => {
      clearTimeout(u), t.forEach((a) => {
        window.removeEventListener(a, i);
      });
    };
  }, [e, t]), s;
}, R = (e, t) => {
  const r = C(null), s = C(null), [c, u] = g(!1);
  p(() => {
    r.current = e;
  }, [e]);
  const i = () => {
    c || (a(), s.current = setInterval(() => {
      r.current();
    }, t), u(!0));
  }, a = () => {
    c && (clearInterval(s.current), s.current = null, u(!1));
  }, l = () => {
    c ? a() : i();
  };
  return p(() => a, []), {
    start: i,
    stop: a,
    toggle: l,
    active: c
  };
}, z = (e, t, r = !0) => {
  const s = C([]), c = O(
    (a) => {
      if (s.current.includes(a.key.toLowerCase()))
        return;
      const l = [...s.current, a.key.toLowerCase()];
      s.current = l, s.current.length === e.length && e.every(
        (f) => s.current.includes(f.toLowerCase())
      ) && r && (a.preventDefault(), t());
    },
    [t, e, r]
  ), u = O((a) => {
    const l = s.current.filter(
      (f) => f !== a.key.toLowerCase()
    );
    s.current = l;
  }, []), i = O(() => {
    s.current = [];
  }, []);
  p(() => (document.addEventListener("keydown", c), document.addEventListener("keyup", u), document.addEventListener("blur", i), document.addEventListener("focus", i), document.addEventListener("beforeunload", i), document.addEventListener("unload", i), () => {
    document.removeEventListener("keydown", c), document.removeEventListener("keyup", u), document.removeEventListener("blur", i), document.removeEventListener("focus", i), document.removeEventListener("beforeunload", i), document.removeEventListener("unload", i);
  }), [r, c, u, i]);
}, A = (e, t) => {
  const [r, s] = g(e), [c, u] = g(t[e]);
  return p(() => {
    u(t[r]);
  }, [r, t]), { locale: r, text: c, changeLocale: (a) => {
    t.hasOwnProperty(a) ? s(a) : console.warn(`Translation not available for locale: ${a}`);
  } };
}, B = (e, t) => {
  const [r, s] = g(() => {
    const u = localStorage.getItem(e);
    return u ? JSON.parse(u) : t;
  });
  return p(() => {
    localStorage.setItem(e, JSON.stringify(r));
  }, [e, r]), [r, (u) => {
    const i = typeof u == "function" ? u(r) : u;
    s(i);
  }];
}, W = (e) => {
  const [t, r] = g(!1), s = () => {
    const c = window.matchMedia(e);
    r(c.matches);
  };
  return p(() => (s(), window.addEventListener("resize", s), () => {
    window.removeEventListener("resize", s);
  }), [e]), t;
}, J = () => {
  const [e, t] = g(/* @__PURE__ */ new Map()), r = O(
    (c, u) => (i, a) => {
      const l = JSON.stringify(i);
      if (e.has(l) && (typeof u == "function" ? u(e.get(l).iv, a) : JSON.stringify(a) === JSON.stringify(e.get(l).iv)))
        return e.get(l).cv;
      const f = c(i, a);
      return e.set(l, { iv: a, cv: f }), f;
    },
    [e]
  ), s = O(() => {
    t(/* @__PURE__ */ new Map());
  }, []);
  return { memoize: r, clear: s };
}, K = (e, t) => {
  const r = (s) => {
    e.current && !e.current.contains(s.target) && t();
  };
  return p(() => {
    const s = (c) => {
      r(c);
    };
    return document.addEventListener("click", s), () => {
      document.removeEventListener("click", s);
    };
  }, [t]), e;
}, j = (e) => {
  const t = C();
  return p(() => {
    t.current = e;
  }, [e]), t.current;
}, _ = (e) => {
  const [t, r] = g(e[0]);
  return [t, (c) => {
    if (c)
      r(c);
    else {
      const i = (e.indexOf(t) + 1) % e.length;
      r(e[i]);
    }
  }];
};
export {
  k as useAnimation,
  S as useCounter,
  T as useDebounce,
  D as useDimensions,
  x as useDraggable,
  M as useEmulatedFieldChange,
  V as useForm,
  N as useId,
  P as useIdle,
  R as useInterval,
  z as useKeyboardShortcut,
  B as useLocalStorage,
  A as useLocalization,
  W as useMediaQuery,
  J as useMemoization,
  K as useOutsideClick,
  j as usePrevious,
  _ as useToggle
};
